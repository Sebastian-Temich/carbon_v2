{"ast":null,"code":"const token = '%[a-f0-9]{2}';\nconst singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nconst multiMatcher = new RegExp('(' + token + ')+', 'gi');\nfunction decodeComponents(components, split) {\n  try {\n    // Try to decode the entire string first\n    return [decodeURIComponent(components.join(''))];\n  } catch (_unused) {\n    // Do nothing\n  }\n  if (components.length === 1) {\n    return components;\n  }\n  split = split || 1;\n\n  // Split the array in 2 parts\n  const left = components.slice(0, split);\n  const right = components.slice(split);\n  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input);\n  } catch (_unused2) {\n    let tokens = input.match(singleMatcher) || [];\n    for (let i = 1; i < tokens.length; i++) {\n      input = decodeComponents(tokens, i).join('');\n      tokens = input.match(singleMatcher) || [];\n    }\n    return input;\n  }\n}\nfunction customDecodeURIComponent(input) {\n  // Keep track of all the replacements and prefill the map with the `BOM`\n  const replaceMap = {\n    '%FE%FF': '\\uFFFD\\uFFFD',\n    '%FF%FE': '\\uFFFD\\uFFFD'\n  };\n  let match = multiMatcher.exec(input);\n  while (match) {\n    try {\n      // Decode as big chunks as possible\n      replaceMap[match[0]] = decodeURIComponent(match[0]);\n    } catch (_unused3) {\n      const result = decode(match[0]);\n      if (result !== match[0]) {\n        replaceMap[match[0]] = result;\n      }\n    }\n    match = multiMatcher.exec(input);\n  }\n\n  // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n  replaceMap['%C2'] = '\\uFFFD';\n  const entries = Object.keys(replaceMap);\n  for (const key of entries) {\n    // Replace all decoded components\n    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n  }\n  return input;\n}\nexport default function decodeUriComponent(encodedURI) {\n  if (typeof encodedURI !== 'string') {\n    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n  }\n  try {\n    // Try the built in decoder first\n    return decodeURIComponent(encodedURI);\n  } catch (_unused4) {\n    // Fallback to a more advanced decoder\n    return customDecodeURIComponent(encodedURI);\n  }\n}","map":{"version":3,"names":["token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","split","decodeURIComponent","join","_unused","length","left","slice","right","Array","prototype","concat","call","decode","input","_unused2","tokens","match","i","customDecodeURIComponent","replaceMap","exec","_unused3","result","entries","Object","keys","key","replace","decodeUriComponent","encodedURI","TypeError","_unused4"],"sources":["/Users/st/Documents/carbon/front/node_modules/decode-uri-component/index.js"],"sourcesContent":["const token = '%[a-f0-9]{2}';\nconst singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nconst multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn [decodeURIComponent(components.join(''))];\n\t} catch {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tconst left = components.slice(0, split);\n\tconst right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch {\n\t\tlet tokens = input.match(singleMatcher) || [];\n\n\t\tfor (let i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher) || [];\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tconst replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD',\n\t};\n\n\tlet match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch {\n\t\t\tconst result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tconst entries = Object.keys(replaceMap);\n\n\tfor (const key of entries) {\n\t\t// Replace all decoded components\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nexport default function decodeUriComponent(encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}